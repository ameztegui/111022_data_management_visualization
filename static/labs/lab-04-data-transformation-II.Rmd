---
title: "Data transformation (II): Piping and conditional transformations"
date: "111022 | Data management and visualization with R"
author: 
  - "Aitor Ameztegui"
  - "Marcos Rodrigues"
output:
  rmdformats::readthedown:
    highlight: pygments
    number_sections: true
    css: lab.css
# runtime: shiny_prerendered
---

```{r include=FALSE}
library(tidyverse)
library(knitr)
options(
  htmltools.dir.version = FALSE, # for blogdown
  show.signif.stars = FALSE,     # for regression output
  digits = 2
  )
#knitr::opts_chunk$set(eval = FALSE)
load('data/data_IFN.Rdata')
```


# Piping

In the last lab, we have seen how to create new variables with `mutate`, how to select the desired rows and columns with `filter`and `select`, how to sort our datasets with `arrange` or create summarised variables with `summarise`. Most often, however, we will want to apply several of this verbs to a dataframe. For instance, we may want to first calculate the basal area of each tree, then get the total basal area per plot, and then determine the average basal area per plot per dominant species.

The typical way to concatenate different functions in R is to successively apply each verb to the result of the previous operation, using parentheses. This forces us to work "from inside to outside", and the result gets reall hard to read or understand. For instance, let's think what the following commands are doing:

```{r bad_left, eval = FALSE}
diam_especie <- filter(
  summarise(
    group_by(
      filter(
        trees, !is.na(DiamIf3)
      ),
      Codi, Especie
    ),
    diam = mean(DiamIf3),
    n = n()
  ),
  n > 5
)
```


With some effort, we could understand the code, but it is not easy to read. Another option is to create intermediate objects at each step, as follows:

```{r bad_right, eval = FALSE}
no_na_trees <- filter(
  trees, !is.na(DiamIf3)
)
no_na_trees_grouped <- group_by(
  no_na_trees, Codi, Especie
)
summarised_no_na_trees <- summarise(
  no_na_trees_grouped,
  diam = mean(DiamIf3), n = n()
)
final_data <- filter(
  summarised_no_na_trees, n > 5
)
```

This approach is easier to understand, but has two main disadvantages:

1. It forces us to create intermediate objects that occupy memory and are not longer used.
2. Is prone to mistakes if some of the steps causes errors.

The `tidyverse` has adopted a very clever approach, inherited from the `magrittr` package: the *pipe* operator. A *pipe* is just this symbol `%>%`, and makes that the result of the left side is passed to the function in the right as first argument. So  `x %>% f(y)`  is the same as `f(x,y)`, and `x %>% f(y, z)`, would be the same as `f(x, y, z)`. We saw that, in the tidyverse, the first argument was always the data frame at which we apply the operations. This makes that, within the tidyverse `%>%` makes each function to be applied to the data frame resulting from the previous step.
  
  `filter(df, color == 'blue')` is the same as `df %>% filter(color == 'blue')`  
  
 Tidyverse verbs can thus be applied consecutively to a data frame, in a more intuitive order. So for example, the previous example would be
 
```{r ok_right, eval = FALSE}
diam_especie <- trees %>%
  filter(!is.na(DiamIf3)) %>%
  group_by(Codi, Especie) %>%
  summarise(
    diam = mean(DiamIf3),
    n = n()
  ) %>%
  filter(n > 5)

```
 
 If we read the `%>%`operator as **THEN**, it is easy to understand that piece of code:

```{r ok_right_commented, eval = FALSE}
diam_especie <- trees %>%               # Get the data frame trees and THEN
  filter(!is.na(DiamIf3)) %>%           # filter those that have diameter value, and THEN
  group_by(Codi, Especie) %>%           # for each plot and species
  summarise(                            # calculate 
    diam = mean(DiamIf3),               # the mean diameter
    n = n()                             # and the number of trees in the plot
  ) %>%                                 # AND THEN
  filter(n > 5)                         # keep only those plots with at leat 5 trees of a given species.
```


<div class=exercise>

**EXERCISE 1:** </br>

Create pipelines to answer the following questions:

  1.1 Which **plots** have the fastest average growth rate?
  
  1.2 Which is the plot with the **most species**?
  
  1.3 Is there any **relationship** between both variables? <br>
  *(Optional, some knowledge on `ggplot`is required)*

</div>

# Operate on a selection of variables

When working with our data frames, we will often be in  the need to apply a certain operation to several variables. For instance, we may be interested in calcukating the mean tree diameter and mean tree height per species in each plot. We can do this by separating each variable within the tidyverse with commas, such as here:

```{r}
trees %>%
    group_by(Codi, Especie) %>%
    summarise(mean_d2 = mean(DiamIf2),
              mean_d3 = mean(DiamIf3),
              mean_h = mean(HeiIf3))
```

This code above is perfectly valid. However, when we want to repeat the same operation to several variables, `dplyr`has variants of its verbs that are more convenient:

1. `summarise_all` will apply an operation on all variables

2. `summarise_if` applies the selected function to those variables that meet a condition. For instance, we can get the `mean` of any variable (columnn) containting numerical data:

```{r, eval = T}
trees %>%
    group_by(Codi, Especie) %>%
    summarise_if(is.numeric, mean)
```

If we only apply a function (in this case, `mean`), dplyr will substitute the name of the original variables by the summary. We can calculate however several functions by providing them as a list, and dplyr will add a suffix to the variable name to identify them.

```{r, eval = T}
trees %>%
    group_by(Codi, Especie) %>%
    summarise_if(is.numeric, .funs= list(mean, sd))
```

If we want the suffix to be more informative, we can provide names to the functions:

```{r, eval = T}
trees %>%
    group_by(Codi, Especie) %>%
    summarise_if(is.numeric, .funs= list(avg = mean, sd = sd))
```

3. With `summarise_at` we can limit the summary to certain variables, by name or using the select helpers (`starts_with`, `ends_with`, `one_of`). 

```{r summarise_at}
trees %>%
    group_by(Codi, Especie) %>%
    summarise_at(vars(starts_with('Dia')), mean)
```

> The variants `_at()`, `_if()`, and `_all()` can be applied to any of the main verbs of dplyr. So we have `mutate_at()`, `mutate-if()`, and `mutate_all()`, which can be also very useful and work similarly to the `summarise_*` family, but also `filter_at()`, `filter_if()`, `filter_all()`; `select_if()`, `select_at()`, and `select_all()`, or `arrange_if()`, `arrange_at()` and `arrange_all()`.We even have `group_by_at()` and `group_by_if()`. However, the behavior of these variants can be a little tricky, so check the [`dplyr`website](https://dplyr.tidyverse.org/reference/scoped.html) to get a deeper understanding or their functioning.

<div class=exercise>

**EXERCISE 2:** </br>

Use the scoped variants of `mutate` to:

2.1. Log-transform those columns in trees containing numerical variables

2.2. Calculate the maximum and minimum of all variables that represent a date in the `plots` data frame


</div>


# Grouped `mutate`/`filter`: summary functions vs. window functions

We will commonly use groups (`group_by`) when summarising variables. These are called "summary functions", because they reduce from *n* inputs to one input
![](images/03-data-transformation/summary_function.png){width=500px}

```{r}
trees %>% 
    group_by(Especie) %>% 
    summarise(mean = mean(DiamIf3))
```

Sometimes, however, we may be interested in calculating new variables by group, but without reducing the dimensions. These are called "window functions", because the *n* inputs always give *n* outputs.

![](images/03-data-transformation/window_function.png){width=500px}

For example, we could add a new variable that is the mean diameter of each species:

```{r eval = F}

trees %>%
  group_by(Especie) %>%
  mutate(avg_d = mean(DiamIf3))
```

This function calculates the mean diameter per species but, instead of collapsing our dataframe, adds one column but keeps the number of rows. This can be interesting if we want to calculate, for example, the differences between individual observations and a given value (mean, sd, IQR), to detect outliers:

```{r eval = F}

trees %>%
  group_by(Especie) %>%
  mutate(std_diam = DiamIf3 - mean(DiamIf3))
```


<div class="exercise" >

**EXERCISE 3**</br>

  3.1 Identify those trees that grew most as compared to the average in that plot <br>
  .font80[(Hint: calculate growth, *then* mean growth by plot, and *then* the difference)]
  
  3.2 Identify those plots where a species grows much more than the average for the species

**Extra (in case you get bored):**  

  3.3 Select IFN plots with pure Pinus nigra stands (Especie = 025). Note: we consider a forest to be monospecific when > 80% in BA corresponds to a single species
  
 </div>
 
 
 Similarly, `group_by()`can also be used combined with `filter()` to retain, for each group, only those observations that accomplish a certain condition:
 
```{r}
trees %>%
    group_by(Codi) %>%
    filter(n() > 20)
```

This will return all the observation from those plots where there are at least 20 trees measured.

When doing grouped mutates, two functions that become interesting are `lead()` and `lag()`, which allow you to access the previous and next values in a vector, making it easy to compute differences and trends.


# Conditional transformations

Sometimes we may be interested in calculating new variables, but conditioned to certain criteria. We can do this with the `ìf_else()` operator. `if_else()`allows to implement a conditional structure in which we determine the output value when the condition is met, and the value otherwise. For instance, imagine we want to define the name of the species for those trees that are *Pinus sylvestris* (code 021) but we are not interested in the others

```{r}
trees %>%
    mutate(sp_name = if_else(Especie == "021", "Pinus sylvestris", "Other"))
```


<div class="exercise">
**EXERCISE 4** </br>

Create a new variable that assigns the value "big" to those trees with diameter greater than 40 cm, and "small" otherwise. 

</div>

If we want to create several different outputs, we could combine several `ìf_else()` statements, but the code can get difficult to read easily. An alternative is to use the function `case_when()`. This function allows you to vectorise multiple `if_else()` statements. It is an R equivalent of the SQL CASE WHEN statement. `case_when()` has a more particular notation, since it requires a sequence of two-sided formulas. The left hand side (LHS) determines which values match this case. The right hand side (RHS) provides the replacement value. If no cases match, NA is returned. 

For instance, following the previous example, let's assign its name to *Pinus sylvestris* (021), *Pinus nigra* (025), *Pinus uncinata* (022), and *Pinus halepensis* (024)


```{r}
trees %>%
    mutate(sp_name = case_when(
        Especie == "021" ~ "Pinus sylvestris",
        Especie == "025" ~ "Pinus nigra",
        Especie == "022" ~ "Pinus uncinata",
        Especie == "024" ~ "Pinus halepensis",
        TRUE             ~ "Other" )      # This last statement is needed to indicate what to do when none of the conditions is met
    )
```

<div class="exercise">
**EXERCISE 5** </br>

Use `case_when()` to create a new variable that assigns the value "big" to those trees with diameter greater than 40 cm, "medium" to those between 20 and 40 cm, and "small" otherwise

</div>






