---
title: "Functional programming within the tidyverse"
date: "111022 | Data management and visualization with R"
author: 
  - "Aitor Ameztegui"
  - "Marcos Rodrigues"
output:
  rmdformats::readthedown
number_sections: true
css: lab.css
# runtime: shiny_prerendered
---

```{r include=FALSE}
library(tidyverse)
library(sf)
library(knitr)
options(
  htmltools.dir.version = FALSE, # for blogdown
  show.signif.stars = FALSE,     # for regression output
  digits = 2
  )
#knitr::opts_chunk$set(eval = FALSE)
load('data/data_IFN.rdata')
trees %>% filter(Provincia == "25") -> lleida_trees
trees %>% filter(Provincia == "08") -> barcelona_trees
trees %>% filter(Provincia == "17") -> girona_trees
trees %>% filter(Provincia == "43") -> tarragona_trees
```


# Introduction

So far we have seen how to transform one or several data frames in order to get the information we need for our data science project. We have learned how to create new variables, filter observations, join several tables or calculate summary statistics, among many other tools. These are operations that we will apply very often, and sometimes you may be in the need to apply a given sequence of steps repeteadly. In those cases, you  may consider writing a function. 

Writing good functions is a difficult task, and can be a lifetime journey. At the beginning, it will take you more time to create the function than to repeat the needed ope¡ration 3, 4 or even 10 times. But functions allow you to automate common tasks in a more powerful and general way than copy-and-pasting.

Writing a function has three main big advantages over using copy-and-paste (Wickham & Grolemund, 2016):

1. You eliminate the chance of making incidental mistakes when you copy and paste (i.e. updating a variable name in one place, but not in another).

2. As requirements change, you only need to update code in one place, instead of many.

3. You can give a function an evocative name that makes your code easier to understand.

# Functional sequences

The `magrittr` package, where the pipe operator (`%>%`) was designed, allows for saving piped sequences of operations as pseudo-functions in a readable format. We just need to string functions together with pipes and replace the initial object (a data frame) with the dot placeholder (`.`) This creates a function in its own right, but a special case called functional sequence.  The dot may be considered as the unique argument of the pseudofunction, and will pass the dataframe to which the pseudofunction will be applied to. 

Let's see an example: imagine that we had the information about the trees in the National Forest Inventory separated by provinces. In fact, you don't have to imagine too much, because this is actually how the information is provided by the Ministry. Now, let's say we want to calculate the mean tree growth per plot for each of the 50 provinces in Spain. Of course, we can do it one by one, as in:

```{r, eval = FALSE}
lleida_trees %>%
    mutate(growth = DiamIf3- DiamIf2) %>%
    group_by(Codi) %>%
    summarise(mean_growth = mean(growth, na.rm = T))

barcelona_trees %>%
    mutate(growth = DiamIf3- DiamIf2) %>%
    group_by(Codi) %>%
    summarise(mean_growth = mean(growth, na.rm = T))

# and so on
```

However, this is not too efficient for the 3 reasons mentioned above. Imagine if, after typing the code above for 50 times, we decide it is better to calculate the median growth besides the average growth. So instead, we can save the sequence of operations as this:


```{r}
 mean_plot_growth <- . %>%
    mutate(growth = DiamIf3- DiamIf2) %>%
    group_by(Codi) %>%
    summarise(mean_growth = mean(growth, na.rm = T))
```

The sequence has been stored as an R object, if we print it in the console we will see it has the class `functional sequence` and it will print the ordered sequence of operations it executes:

```{r}
mean_plot_growth
```

So we can now apply the pseudofunctions to any dataframe:

```{r}
mean_plot_growth(lleida_trees)
mean_plot_growth(barcelona_trees)
mean_plot_growth(tarragona_trees)
girona_trees %>% mean_plot_growth()     # different flavour of the same operation

```

We still need to call the function several times, but if we decide to change anything, we just need to modify it in the pseudo-function and rerun the code.

We can even combine the functional sequence with any other `tidyverse` functions:

```{r ejemplo functional sequence 3}

# This will apply the operation only to Pinus sylvestris trees
    lleida_trees %>%
        filter(Especie == "021") %>%
        mean_plot_growth()

# This will apply the operation to all plots but will retain only those plots that grow in average more than 5 cm between both inventories.
    lleida_trees %>%
        mean_plot_growth() %>%
        filter(mean_growth >= 5)
```

We can use this functionality of `magrittr` to create functions that can then be applied with any of the variants of `mutate` such as `mutate_at` or `mutate_if`. Imagine we want to calculate (for some reason) the squared root of the log of the diameters measured in the inventory:

```{r}

# We create our function
log_sqr <- . %>%
    log() %>%
    sqrt()

# We apply it to diameter variables
trees %>% 
    mutate_at(.vars=c("DiamIf2", "DiamIf3"),
              .funs = log_sqr)
```


# Functions

Although `magrittr` functional sequences can act as functions and are an easy and efficient way of programming within the tidyverse, they are not "real" functions as it is commonly understood in R. A true R function should work in any environment, not only with piped operations, and typically has the following look:

```{r, eval = FALSE}

my_function <- function (argument1, argument2) {
    operation1
    operation2
    output
}
```

Imagine, for example, that we want to rescale the diameters in the "trees" dataframe.

>Rescaling a variable means make it have a range from 0 to 1. We can achieve this by substracting each value from the minimum and dividing the result by the range:


```{r}
rescale <- function (x) {
    (x-min(x, na.rm = T)) / (max(x, na.rm = T)- min(x, na.rm = T))
}
```

And this could be applied in the same way as we did before with the log_sqr2 pseudo-function:

```{r}
trees %>% 
    mutate_at(.vars=c("DiamIf2", "DiamIf3"),
              .funs = rescale) 
```

There are three key steps to creating a new function:

1. You need to pick a name for the function. Here we’ve used rescale because this function rescales a vector to lie between 0 and 1.

2. You list the inputs, or arguments, to the function inside function. Here we have just one argument, the variable to rescale. If we had more the call would look like function(x, y, z).

3. You place the code you have developed in the body of the function, a `{` block that immediately follows `function(...)`.

Converting a more complicated piece of code into a function can be more challenging. A good tip is to first analyse the code. How many inputs does it have?

If we analyse the example above (`mean_plot_growth`) we could say it only has one input, the dataframe (which was there represented by the dot placeholder). To make the inputs more clear, it’s a good idea to rewrite the code using temporary variables with general names. Here this code only requires a single data frame, so we’ll call it df:

```{r}
df <- lleida_trees
df %>%
    mutate(growth = DiamIf3- DiamIf2) %>%
    group_by(Codi) %>%
    summarise(mean_growth = mean(growth, na.rm = T))
```

So once we have identified the inputs, we convert them in arguments of the function, as in:

```{r}
 mean_plot_growth2 <- function (df) {
    df %>%
    mutate(growth = DiamIf3- DiamIf2) %>%
    group_by(Codi) %>%
    summarise(mean_growth = mean(growth, na.rm = T))
}
```

and so we can now apply the function to any dataframe that has the variables *Codi*, *DiamIf3*, *DiamIf2*, *Especie*...

```{r}
mean_plot_growth2(lleida_trees)
mean_plot_growth2(barcelona_trees)

```

## Tidy eval: Programming in the tidyverse

What if we want to generalize a bit more the function for average growth? One option could be to convert the grouping variable in an argument of the function, so that the user could define if they want the mean growth per plot, per species... Let's try this

```{r}
 mean_plot_growth3 <- function (df, grouping_var) {
    df %>%
    mutate(growth = DiamIf3- DiamIf2) %>%
    group_by(grouping_var) %>%
    summarise(mean_growth = mean(growth, na.rm = T))
}
```

And now we could do:

```{r, error = T}
mean_plot_growth3(lleida_trees, Especie)

```
But hey!, we get an error message saying that it cannot recognize which column is "grouping_var". This is because most dplyr functions use non-standard evaluation (NSE). This is a catch-all term that means they don’t follow the usual R rules of evaluation. This has two main benefits for dplyr code:

1. Operations on data frames can be expressed succinctly because you don’t need to repeat the name of the data frame. For example, you can write `filter(df, x == 1, y == 2, z == 3)` instead of `df[df$x == 1 & df$y ==2 & df$z == 3, ]`.

2. `dplyr` can choose to compute results in a different way to base R. This is important for database backends because `dplyr` itself doesn’t do any work, but instead generates the SQL that tells the database what to do.

As a consequence, dplyr will first look for the column `grouping_var` in the dataframe, without noticing that `grouping_var` should in this case take the value specified in the function.  That means that whenever we want to use a `dplyr` verb within a function, we must operate a bit differently. In this case, with the `{{` operator, you can tunnel data-variables (i.e. columns from the data frames) through arg-variables (function arguments):

```{r}
 mean_plot_growth3 <- function (df, grouping_var) {
    df %>%
    mutate(growth = DiamIf3- DiamIf2) %>%
    group_by({{grouping_var}}) %>%
    summarise(mean_growth = mean(growth, na.rm = T))
 }
```

The tunnel makes it possible to supply variables from the data frame to your wrapper function:

```{r}
mean_plot_growth3(lleida_trees, Especie)
mean_plot_growth3(lleida_trees, Codi)
mean_plot_growth3(lleida_trees, CD)
```



# To know more

There's a lot more to know about tidy evaluation, and more operators in the `rlang` package, but these are only needed for advanced uses of R that go beyond the scope of this course. You can read more at https://tidyeval.tidyverse.org, and you can learn more on tidy eval and tunneling variables by reading this blog post in the [tidyverse blog](https://www.tidyverse.org/blog/2020/02/glue-strings-and-tidy-eval/), or checking the [programming vignette](https://cran.r-project.org/web/packages/dplyr/vignettes/programming.html) for `dplyr`. To get an even more advanced understanding on meta programming with tidy eval, I recommned the chapter on the second edition of the book ["Advanced R"](http://adv-r.hadley.nz/) or the 1-hour [webinar by RStudio](https://resources.rstudio.com/webinars/tidyeval).

To know more about functions and programming in general, check the ["Functions" chapter](https://r4ds.had.co.nz/functions.html) in R for data Science, or the ["Advanced R"](http://adv-r.hadley.nz/) book.

 
