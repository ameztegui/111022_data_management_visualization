---
title: "Manipulating colors"
date: "111022 | Data management and visualization with R"
author: 
- "Aitor Ameztegui"
- "Marcos Rodrigues"
bibliography: "references/biblio.bib"
output:
  rmdformats::readthedown:
  highlight: pygments
number_sections: true
css: lab.css
# runtime: shiny_prerendered
---
  
  
```{r knitr_init, echo=FALSE, cache=FALSE, warning=FALSE}

library(knitr)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
               cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```


```{r include=FALSE}
library(tidyverse)

options(
  htmltools.dir.version = FALSE, # for blogdown
  show.signif.stars = FALSE     # for regression output
)
fires <- read.csv('data/fires.csv')
```

Color is perhaps the main aesthetic, or at least one the most frequently used. Of all the Elements of Design, color is probably the most challenging to understand.

> DISCLAIMER: we are goint to use `fill` and `color` indistinctly in this lab. To all effects, the functions we are going to see here work for both. We just need to change *fill* with *color*, and vice versa. Thus, `scale_fill_gradientn` is the equivalent of `scale_color_gradientn`.

# Properties of Color

To properly manipulate and use color we must understand its basic components.

- *Hue*: Hue is the name of a pure color, such as red, blue, or yellow.
- *Value*: Value is the lightness or darkness of a hue (color). The value of a hue can be changed by adding black or white. Light values of colors are called tints. Darker values of colors are called shades.
- *Intensity*: Intensity is the brightness or dullness of a hue (color). Pure hues are high-intensity colors. Dull hues are low-intensity colors. Intensity of color is changed by adding varying amounts of its complimentary color. For example, to make a bright green duller a little bit of red could be added to it.

As a rule of thumb, *warm colors* are colors that reming us of things that are warm:they are red, yellow and orange; whereas *cool colors* remind us of things we associate with cold or coolness. they are blue, violet and green.

# Qualitative color scales

We frequently use color as a means to distinguish discrete items or groups that do not have an intrinsic order, such as different countries on a map or different manufacturers of a certain product. In this case, we use a qualitative color scale. Such a scale contains a finite set of specific colors that are chosen to look clearly distinct from each other while also being equivalent to each other. The second condition requires that no one color should stand out relative to the others. And, the colors should not create the impression of an order, as would be the case with a sequence of colors that get successively lighter. 

![](https://serialmentor.com/dataviz/color_basics_files/figure-html/qualitative-scales-1.png)

## Color to represent data

Color can also be used to represent data values, such as income, temperature, or speed. In this case, we use a sequential color scale. Such a scale contains a sequence of colors that clearly indicate (i) which values are larger or smaller than which other ones and (ii) how distant two specific values are from each other. The second point implies that the color scale needs to be perceived to vary uniformly across its entire range.

- *Sequential scales* can be based on a single hue (e.g., from dark blue to light blue) or on multiple hues (e.g., from dark red to light yellow)

![](https://serialmentor.com/dataviz/color_basics_files/figure-html/sequential-scales-1.png)

- *Diverging scales* are used when we need to visualize the deviation of data values in one of two directions relative to a neutral midpoind. We can think of a diverging scale as two sequential scales stiched together at a common midpoint, which usually is represented by a light color.

![](https://serialmentor.com/dataviz/color_basics_files/figure-html/diverging-scales-1.png)

# Using colors in `ggplot`

## Use a single color

The most basic way to use color, either in border lines or when filling a polygon or areal shape, it's a single color spectification. Contrary to what we are going to see in the next color applications, applying a single color (or mapping any other single aesthetic with a constant value) **must be always done outside the `aes()` environment** within any `geom`. 

But, how do we specify colors? There are many ways to do so, but the most common ones are:

- Invoking default colors (and their specific variations) by name:

![](https://www.r-graph-gallery.com/img/graph/42-colors-names.png)

> Passing colors by name is alwasy done using `characters` i.e., `"azure"`.

- or using *hexadecimal* color nomenclature via *color builders* like https://htmlcolorcodes.com/. 

> Note the *hex* color codes always begin with `#`

## Mapping colors into aesthetics

The use of single color, while useful to prevent uglyfulness, its seldom the way to go when plotting multiple varibles. Usually we want to `map` a color pattern using a `variable` or atribute of our data. Depending on the type of variable, either categorical or numerical, when can `map` individual colors by group, or build continuous color ramps scaled on the basis of a numerical value.

### Discrete data: groups and intervals

In this case we `map` a category or group into a color/fill aesthetic. Each class is assign a color so we can easily investigate differences between classes or groups.

`Mapping` groups or categories is an easy task. We just need to pass a variables into a `color` or `fill` aesthetic and `ggplot` will assign a color automatically.

However, a sometimes we want to group a numeric/continuous variable into a small subset of categories, aka, intervals. To do so, we can transform interval ranges into single categories using the `cut` function inside a `mutate` call. The ggplot2 package has 3 functions that work well for these tasks:

- `cut_number()`: Makes n groups with (approximately) equal numbers of observation
- `cut_interval()`: Makes n groups with equal range
- `cut_width`: Makes groups of width width

Of course, the most basic way to proceed would be using the `cut` function from base R.

```{r eval=FALSE}
cut(numericVector, breaks, labels = c("low","med","high"))
```

> The `breaks` argument can be constructed either manually with a regular vector or using any statistical function such as `quantile`.

> When using labels make sure that the number of labels matches the number of final intervals.

> We can use -Inf or Inf as initial or final value of the break vector to avoid specifying lower or upper limits.

#### Using brewer palettes

The brewer scales provides sequential, diverging and qualitative colour schemes from ColorBrewer. These are particularly well suited to display **discrete** values on a map.

![](https://www.datanovia.com/en/wp-content/uploads/dn-tutorials/ggplot2/figures/0101-rcolorbrewer-palette-rcolorbrewer-palettes-colorblind-friendly-1.png)

To use any of them we use the function `scale_color_brewer()`, passing the desired `palette`. In the following example we reclassify fires into 3 categories ("small","med","large"), summarize the number of fire events in each category and then display them using a barplot. Bars are colored using a sequential scale. The key concept here is that we transformed a continuous variable (fire size) into ordinal categories, and the used color to reinforce fire classes.

```{r}
fires %>%
  mutate(SIZE = cut(BAREA, c(-Inf,100,500,Inf), labels = c("small","med","large"))) %>%
  group_by(SIZE ) %>%
  summarise(N=n(),BA=sum(BAREA)) %>%
  ggplot() +
    geom_col(aes(y=N,x=SIZE, fill=SIZE)) +
    scale_fill_brewer(palette = 'YlOrRd') +
    theme_bw()
```

#### Asign colors manually

A custom color palettes can be specified using the `scale_color_manual()` functions. Basically, this function expects us to pass it a `vector` with color codes. The function will automatically assign each color following the order of levels in the variable.

```{r}
fires %>%
  mutate(SIZE = cut(BAREA, c(-Inf,100,500,Inf), labels = c("small","med","large"))) %>%
  group_by(SIZE ) %>%
  summarise(N=n(),BA=sum(BAREA)) %>%
  ggplot() +
    geom_col(aes(y=N,x=SIZE, fill=SIZE)) +
    scale_fill_manual(values = c('green','yellow','red')) +
    theme_bw()
```

The alternative is passing a vector with the correspondence between levels and colors (`level = color`):

```{r}
fires %>%
  mutate(SIZE = cut(BAREA, c(-Inf,100,500,Inf), labels = c("small","med","large"))) %>%
  group_by(SIZE ) %>%
  summarise(N=n(),BA=sum(BAREA)) %>%
  ggplot() +
    geom_col(aes(y=N,x=SIZE, fill=SIZE)) +
    scale_fill_manual(values = c('small' = 'lightgreen',
                                 'med' = 'lightyellow',
                                 'large' = 'darkred')) 
```  

#### Using color to highlight

Implementing color schemes in `ggplot` is easy once we become familiar with its ways. But the key to success lies in using it properly. One of the multiple uses that color has is *highlighting* something relevant in a plot. For instance, let`s say we are building a report for an autonomous region to place it in the context of fire incidence. We might be interest in making it more visible. Color is a way to do so. In the following example we represent the relative impact of wildfires in *Cantabria*. We build a separate plot for number of fires (N) and burned area (BA). We use color to *highlight* the position of *Cantabria* regardind the remaining CCAA.

```{r}

library(tidytext)

#Getting data for Cantabria alone
d<- fires %>%
    filter(CCAA == 'Cantabria') %>%
    group_by(CCAA) %>%
    summarise(N=n(), BA = sum(BAREA)) %>%
    pivot_longer(cols = c(N:BA), names_to = 'var' ,values_to = 'value') %>%
    ungroup() %>%
    #reorder_within allows sorting per group
    mutate(CCAA = reorder_within(CCAA,value,var))

#Getting data for all CCAA and plotting
fires %>%
    group_by(CCAA) %>%
    summarise(N=n(), BA = sum(BAREA)) %>%
    pivot_longer(cols = c(N:BA), names_to = 'var' ,values_to = 'value') %>%
    ungroup() %>%
    mutate(CCAA = reorder_within(CCAA,value,var)) %>%
    ggplot() +
        geom_col(aes(y=reorder(CCAA,value),x=round(value,0),group = var), fill = 'steelblue', width = 0.7) +
        geom_col(data=d,aes(y=reorder(CCAA,value),x=round(value,0),group = var), fill = 'coral3', width = 0.7) +
        scale_y_reordered(name = 'CCAA') +
        labs(x='') +
        facet_wrap(~var, scales = 'free') +
        theme_minimal() +
        theme(panel.grid = element_blank())
```


### Continuous colors

*Sequential* and *Diverging* scales are normally applied over numerical continuous data. We have seen how `ggplot` changes automatically the color scheme depending on the type of variable we are mapping. When passing any numerical variable we get a *sequential* blue palette:

```{r}
fires %>%
    group_by(MONTH,YEAR) %>%
    summarise(BA=mean(BAREA),N=n()) %>%
    ggplot() +
        geom_point(aes(x=N,y=log(BA),color = BA)) +
        theme_bw()
```

`ggplot` offers several alternatives to manipulate color scale for continuous variables. There are *standard* functions like the `scale_xxx_grandient` family that provide default color ramps but also let us build our own. You can get a full description of this set of funtions here https://ggplot2.tidyverse.org/reference/scale_gradient.html. Basically, these functions allow to set a color for the lowest (`low`) and highest (`high`) value of the variable, automatically building the intermediate gradient. Some of them, like `scale_color_gradientn` also allow to establish a color for the `midpoint` (which by default is located at 0) using `mid` so that we can easily build a *diverging* color ramp.

```{r}
fires %>%
    filter(YEAR > 1900) %>%
    group_by(YEAR) %>%
    summarise(N=n(), BA=sum(BAREA)) %>%
    ggplot() + 
        geom_col(aes(x=YEAR,y=N,fill=BA*0.01)) +
        scale_fill_gradient2() +
        theme_bw()

```

```{r}
fires %>%
    filter(YEAR > 1900) %>%
    group_by(YEAR) %>%
    summarise(N=n(), BA=sum(BAREA)) %>%
    ggplot() + 
        geom_col(aes(x=YEAR,y=N,fill=BA*0.01)) +
        scale_fill_gradient2(midpoint  = 2500) +
        theme_bw()

```

> Same as with `scale_x_xxxx` and `scale_y_xxxx` we can pass a `name` argument to modify the name of the scale in the legend.

```{r}
fires %>%
    filter(YEAR > 1900) %>%
    group_by(YEAR) %>%
    summarise(N=n(), BA=sum(BAREA)) %>%
    ggplot() + 
        geom_col(aes(x=YEAR,y=N,fill=BA*0.01)) +
        scale_fill_gradient2(name = 'Burned area (sq. Km)',
                             midpoint  = 2500 #Setting the center at 0
                             ) +
        theme_bw()
```


```{r}
fires %>%
    filter(YEAR > 1900) %>%
    group_by(YEAR) %>%
    summarise(N=n(), BA=sum(BAREA)) %>%
    ggplot() + 
        geom_col(aes(x=YEAR,y=N,fill=BA*0.01)) +
        scale_fill_gradient(low = 'lightgreen', high = 'darkgreen',
            name = 'Burned area (sq. Km)') +
        theme_bw() +
        ggtitle('Green sequential scale')
```

<div class= "exercise">
**EXERCISE 1** </br>

- Do you think the *green* color scale is appropriate to represent increasing burned area?

- Would you have picked another color gradient?

- Do you think a *diverging* scale could be better? Why?

</div>
> Likewise, we can apply `trans` functions to color values to modify the assignment of color.


#### Default color ramps

Same as `ggthemes` or the default themes we have talked about previously, there are several implementations of color functions that are quite handy. Those have been usually developed pursuing an specific purpose so they come very handy.

Perhaps, the most widespread are the *viridis* color ramps. They are a set of color-blind-friendly palettes that are quite popular.

I personally recommend the package `ggsci`, which offers a complete set of color schemes and useful functions to manipulate color in ggplot.

#### Binning continuous scales

The latest developments of `ggplot` include a nice feature that it's kind of inbetween of continuous and discrete visualizations. It is the `scale_color_binned()` functions. It takes a continuous variable and displays it using discrete intervals:

```{r}
fires %>%
    filter(YEAR > 1900) %>%
    group_by(YEAR) %>%
    summarise(N=n(), BA=sum(BAREA)) %>%
    ggplot() + 
        geom_col(aes(x=YEAR,y=N,fill=BA*0.01)) +
        scale_fill_binned(low = 'lightgreen', high = 'darkgreen',
            name = 'Burned area (sq. Km)') +
        theme_bw() +
        ggtitle('Green sequential scale')
```

<div class= "exercise">
**EXERCISE 2** </br>

Create a barplot to order the annual occurrence of fires. You must:

- Calculate the amount of fires above and below the mean
- Display number of fires using a **divergent color ramp centered in 0**

</div>