---
title: "Lab 8.1 - Small multiples, working with facets"
date: "111022 | Data management and visualization with R"
author: 
  - "Aitor Ameztegui"
bibliography: "references/biblio.bib"
output:
  rmdformats::readthedown:
  highlight: pygments
number_sections: true
css: lab.css
# runtime: shiny_prerendered
---
  
  
```{r knitr_init, echo=FALSE, cache=FALSE, warning=FALSE}

library(knitr)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
               cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```


```{r include=FALSE}
library(tidyverse)

options(
  htmltools.dir.version = FALSE, # for blogdown
  show.signif.stars = FALSE     # for regression output
)
fires <- read.csv('data/fires.csv')
```


So far we have learnt how to deal with categorical data or gruops of observations by mapping a discrete variable into an appropriate aesthetic (color, shape...). Yet, we have also encounter limitations on that approach, mainly related to the complexity of visualize too much information at once. Having too many group, too many observations or both is usually a major concern.

Faceting (aka small multiples) allows us to create multiple sub plots. It partitions a plot into a matrix of panels with each panel showing a different subset of data. Thus, the `facet` approach partitions a plot into a matrix of panels. Each panel shows a different subset of the data. 

> *Small multiples* are a powerful tool for exploratory data analysis: you can rapidly compare patterns in different parts of the data and see whether they are the same or different. This section will discuss how you can fine-tune facets, particularly the way in which they interact with position scales. 

From an operational standpoint implementing a `facet` split it's simple. We have two funtions:

- `facet_wrap(~group)`: we create as many groups as levels in the `group`
- `facet_grid(group1~group2)`: we create as many groups as combinations of levels in the two `groups`.

# `facet_wrap`

`facet_wrap()` makes a long ribbon of panels (generated by any number of variables) and wraps it into 2d. This is useful if you have a single variable with many levels and want to arrange the plots in a more space efficient manner.
For example, we can break down the histogram of burned area:

```{r}
fires %>%
group_by(CAUSE,MONTH) %>%
    ggplot(aes(x=log(BAREA))) +
    geom_histogram()
```

Into a set of histograms based on a category or gruop. For instance, by month:

```{r}
fires %>%
group_by(MONTH) %>%
    ggplot(aes(x=log(BAREA))) +
        geom_histogram() +
        facet_wrap(~MONTH)
```

As you can see, this is quite powerfull. Not only makes the plot more appealing but it enhances the visualization in the sense of improving our perception of the phenomena. Now we can clearly see how the fire size distribution changes through months or seasons.

> Remember that the grouping variable in `facet_wrap` is always passed on the left of the `~` (*Alt gr* + *4* + *space bar* ).

# `facet_grid`

`facet_grid` seeks a similar purpose but allowing us to pass two groups so that we can explore the interaction between two factors. For instace, cause and month:

```{r}
fires %>%
    group_by(CAUSE,MONTH) %>%
    ggplot(aes(x=log(BAREA))) +
        geom_histogram() +
        facet_grid(CAUSE~MONTH)
```

However, we must be careful when `faceting`. In the above example perhaps we went too far in terms of the resulting number of groups.

> The order in which we pass the groups into `facet_grid` determines the arrangment of the subplots (right - cols & left - rows).

# Manipulating the arrangement

In `facet_wrap` we can change the disposition of the plots in several ways. You can control how the ribbon is wrapped into a grid with `ncol`, `nrow`, `as.table` and `dir`. `ncol` and `nrow` control how many (e.g., `ncol = 3`) columns and rows (you only need to set one). `as.table` controls whether the facets are laid out like a table (*TRUE*), with highest values at the bottom-right, or a plot (*FALSE*), with the highest values at the top-right. dir controls the direction of wrap: horizontal or vertical.

<div class = "exercise">

**EXERCISE 1** </br>
Use the `facet_wrap` example to explore on you own how `ncol`, `nrow`, `as.table` and `dir` alter the arrangement of the elements of the plot.
</div>
> The arrangement and labels of `facet`'s panels depends on the levels of the variable we use. To control or reorder how them we must change the actual levels of the variable as we saw when working with the `forcats` package.

# Improving facet visualization

So far we have covered the necessary contents to implement facets. Nonetheless, it's up to us to decide the ultimate information that goes into a plot. The examples we went through comprise a single `geom` layer. At this stage it suffices to say we can add as many layers as we need and the ggplot will do the rest:

```{r}
fires %>%
    filter(YEAR>1900) %>%
    na.omit() %>%
    group_by(CAUSE,YEAR) %>%
    summarise(BA=sum(BAREA)) %>%
        ggplot(aes(y=BA,x=YEAR)) +
            geom_col() +
            geom_smooth() +
            facet_wrap(~CAUSE, ncol = 2)
```

```{r}
fires %>%
    group_by(YEAR,MONTH,CAUSE) %>%
    summarise(BA=sum(BAREA),N=n()) %>%
        ggplot() +
            geom_point(aes(x=BA,y=N,color = factor(CAUSE),shape=factor(CAUSE)), size=0.5) +
            geom_smooth(aes(x=BA,y=N,color = factor(CAUSE))) +
            facet_wrap(~CAUSE, ncol = 2)
```


```{r}
fires %>%
    group_by(YEAR,MONTH,CAUSE) %>%
    summarise(BA=sum(BAREA),N=n()) %>%
        ggplot() +
            stat_summary_hex(aes(x=BA,y=N,z=BA)) +
            facet_wrap(~CAUSE, ncol = 2)

```

However, sometimes we will want to provide some background information to better comprehend patterns and data. A clear example of that is when we try to visualize amounts or frequencies between groups. It is quite easy to lose track of the proportions or differences regarding the original dataset. A simple solution is adding a background layer showing the entire dataset. Conceptually, it is quite straightforwards but we have to really know how ggplot works to be able to do this.

The solution we may come up wiht is adding an additional geom passing it the entire datasete. Then, we add the grouped geom and appy the facet approach:

```{r}
fires %>%
    group_by(CAUSE) %>%
    ggplot() +
        geom_histogram(data=fires, aes(x=log(BAREA)),fill='lightgrey') + #all fires
        geom_histogram(aes(x=log(BAREA))) + #grouped fires
        facet_wrap(~CAUSE) #facetting
```
This doesn't work and the reason behind is simple but tricky. Since the entire dataset still holds the facet variable (MONTH in the example above) the `fires` dataset is split regardless. Solution, drop the factetting variable in the entire dataset:
  
```{r}
fires %>%
  group_by(CAUSE) %>%
  ggplot() +
  geom_histogram(data=dplyr::select(fires,-CAUSE), aes(x=log(BAREA)),fill='lightgrey') + #all fires without MONTH
  geom_histogram(aes(x=log(BAREA))) +
  facet_wrap(~CAUSE)
```

```{r}
fires %>%
  group_by(CAUSE) %>%
  ggplot() +
  geom_density(data=dplyr::select(fires,-CAUSE), aes(x=log(BAREA)),fill='lightgrey', color =NA) + #all fires without MONTH
  geom_density(aes(x=log(BAREA)), color ='red') +
  facet_wrap(~CAUSE)
```

<div class = "exercise">

**EXERCISE 2** </br>
Rename the months of the year from numbers to actual names and display them in the correct order (January-December).
</div>

# Set the facet free

Did you notice that the dimensions of the axes are set to a common scale when we use facets? That is one of the main advantages of it, by doing so everything is directly comparable. Remember that *wrong* plot we saw in the begining of unit 5? Facet overcomes it very easily. But, occasionlly, we might need to use specific data ranges in our plots. To do so, we can set the `scales` option within `facet` to:
  
  - *free*: both x and y axes are adapted to the data in each facet:
  - *free_y*: y axis is adapted automatically.
  - *free_x*: x axis is adapted automatically.
